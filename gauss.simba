{$i srl.simba}

{
  Written by Dr. Steven Beauchemin; Released to Kevin Brightwell (Nava2)
  Calculates numbers within a Gaussian distribution of numbers about the mean
  with +/- the variance (aka. sigma).
}

var
  SRL_GaussRand: function(u, s:Extended): Extended;


{
  Numerically evaluated constants for Normal distribution.
  Set in `setupN2Gauss`
}
var
  __NORM_CONST: TExtendedArray;


(*

Helper method for cal_normal_random. Does polynomial calculation using the
`Horner Scheme`_

..http://en.wikipedia.org/wiki/Horner_scheme

*)
function __gauss_poly(r, rsqr: Extended): Extended;
begin
  Result := __NORM_CONST[0]*rsqr + __NORM_CONST[1];
  Result := Result*rsqr + __NORM_CONST[2];
  Result := Result*rsqr + __NORM_CONST[3];
  Result := Result*rsqr + __NORM_CONST[4];
  Result := Result*r;
end;

(*

rand_normal
~~~~~~~~~~~

Calculates a normal random that is based upon the mean and the standard deviance
passed into the function.

By definition, 68.2% of points will lie within +/- 1*sigma, 95.4% within +/- 2.

*)
function n2_gauss(mean, sigma: Extended): Extended;
var
  r, gauss_rand: Extended;
  i: Integer;
begin
  r := 0.0;
  for i := 0 to 11 do
    r := r + (random(MaxInt)*1.0)/MaxInt;

  r := (r-6.0)/4.0 ;
  gauss_rand:= __gauss_poly(r, r*r);
  result := mean + sigma*gauss_rand;
end;

procedure SetupN2Gauss;
begin
  __NORM_CONST := [ 0.029899776, 0.008355968, 0.076542912,
    0.252408784, 3.949846138 ];
  SRL_GaussRand := @n2_gauss;
end;

(*

Gauss_Point
~~~~~~~~~~~

Calculates a point about cX, cY with radius maxRad. The point is returned in the
reference parameters oX, oY.

.. note::
    by Nava2

Example:
.. code-block:: pascal

    var
      gX, gY: Integer;
    // get a gaussian pt in a circle:
    Gauss_Point(MMCX, MMCY, 0, math_2PI, MMX2-MMCX, gX, gY);
    WriteLn(Format("gX, gY -> %d, %d", gX, gY);

*)

const
  SRL_GAUSS_POINT_DEV = 0.6;

procedure Gauss_Point(cX, cY: Integer; sAngle, eAngle: Extended; maxRad: Integer; out oX, oY: Integer);
var
  angle: Extended;
  radius: Extended;
  xShift, yShift: Integer;
begin

  if (eAngle < sAngle) then
    swap(eAngle, sAngle);

  { random angle about the center }
  angle := sAngle + (eAngle-sAngle)*Random(MaxInt)/MaxInt;

  { get normal pt about zero, where 68% lie within .5*maxRad }
  radius := SRL_GaussRand(maxRad,maxRad*SRL_GAUSS_POINT_DEV) - maxRad;


  { the shifting distance based on the radius and angle (both rand) }
  xShift := round(radius * Cos(angle));
  yShift := round(radius * Sin(angle));

  oX := cX + xShift;
  oY := cY + yShift;
end;

function GaussRange(minI, maxI: Extended): Extended;
var
  valid: Boolean;
  mean: Extended;
  dev: Extended;
  t: Integer;
begin
  { calculate the mean }
  mean := (maxI+minI)/2.0;
  dev  := abs(maxI-minI)/2.0 * 0.333;//1.5;

  t := 0;
  while ((not valid) and (t < 10)) do 
  begin
    Result := SRL_GaussRand(mean, dev);
    valid := ((Result >= minI) and (Result <= MaxI));

    inc(t);
  end;
  
//  WriteLn(Format('We done goofed %d times.', [t-1]));
end;

function iGaussRange(minI, maxI: Integer): Integer;
begin
  Result := Round(GaussRange(minI, maxI));
end;


(*

Gauss_Box
~~~~~~~~~

Calculates a point normally distributed from the center of the passed box. It
checks for outlying points and will regenerate points if necessary.

.. note::
    by Nava2

Example:
.. code-block:: pascal

    var
      gX, gY: Integer;
    // get a gaussian pt in a circle:
    Gauss_Box(gX, gY, MMX1, MMY1, MMX2, MMY2);
    WriteLn(Format("gX, gY -> %d, %d", gX, gY);

*)

procedure Gauss_Box(out px, py: Integer; x1, y1, x2, y2: Integer);
begin
  px := iGaussRange(x1, x2);
  py := iGaussRange(y1, y2);

  if (not PointInBox(Point(px, py), IntToBox(x1, y1, x2, y2))) then
    SRL_Warn('GaussBox',Format('Point invalid (%d, %d)', [px, py]), warn_Terminate);
end;

