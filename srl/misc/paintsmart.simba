

var
  SMART_Canvas: TBitmap;
  SMART_DebugSetup: Boolean;

procedure SMART_SetupDebug();
begin
  SmartSetDebug(True);
  SMART_Canvas := TBitmap.Create;
  SMART_Canvas.canvas.handle := SmartGetDebugDC;
  SMART_DebugSetup := true;
end;

procedure SMART_ClearCanvasArea(w, h: integer; Position: TPoint);
{$IFDEF SMART}
var
  CleanBMP: integer;
begin
  if (not SMART_DebugSetup) then
    SMART_SetupDebug();

  CleanBMP := BitmapFromString(w, h, '');
  DrawBitmap(CleanBMP, SMART_Canvas.Canvas, Position.x , Position.y);

  try
    FreeBitmap(CleanBMP);
  except
    Writeln('SMART_ClearCanvasArea: Couldn''t free CleanBMP');
  end;
{$ELSE}
begin
{$ENDIF}
end;

procedure SMART_ClearCanvas;
begin
  SMART_ClearCanvasArea(MIX2 + 100, MIY2 + 100, Point(0, 0));
end;

procedure SMART_DrawDotsMulti(Clear: boolean; pixels : T2DPointArray);
{$IFDEF SMART}
var
  i, h, color : integer;
begin
  if (not SMART_DebugSetup) then
    SMART_SetupDebug();

  if Clear then SMART_ClearCanvas;

  for h := 0 to High(pixels) do
  begin

    color := h div 5 + h mod 5;
    case color of
      0 : SMART_Canvas.canvas.Pen.Color := clWhite;
      1 : SMART_Canvas.canvas.Pen.Color := clYellow;
      2 : SMART_Canvas.canvas.Pen.Color := clBlue;
      3 : SMART_Canvas.canvas.Pen.Color := clLime;
      4 : SMART_Canvas.canvas.Pen.Color := clGreen;
    end;

    for i:= 0 to High(pixels[h]) do
    begin
      SMART_Canvas.canvas.moveto(pixels[h][i].x-1, pixels[h][i].y);
      SMART_Canvas.canvas.LineTo(pixels[h][i].x, pixels[h][i].y);
    end;
  end;
{$ELSE}
begin
{$ENDIF}
end;

procedure SMART_DrawDotsEx(Clear: boolean; pixels: TPointArray; color: TColor);
{$IFDEF SMART}
var
  i : integer;
begin
  if (not SMART_DebugSetup) then
    SMART_SetupDebug();

  SMART_Canvas.canvas.Pen.Color := color;
  if Clear then SMART_ClearCanvas;

  for i:= 0 to high(pixels) do
  begin
    SMART_Canvas.canvas.moveto(pixels[i].x-1,pixels[i].y);
    SMART_Canvas.canvas.LineTo(pixels[i].x,pixels[i].y);
  end;

{$ELSE}
begin
{$ENDIF}
end;

procedure SMART_DrawDots(Dots: TPointArray);
begin
  SMART_DrawDotsEx(True, Dots, clRed);
end;

procedure SMART_DrawBoxes(Clear: Boolean; TBA: TBoxArray; Color: Integer);
{$IFDEF SMART}
var
  i, colour: Integer;
begin
  if (not SMART_DebugSetup) then
    SMART_SetupDebug();

  if Clear then SMART_ClearCanvas;

  if (Length(TBA) < 1) then Exit;
  for i := 0 to High(TBA) do
  begin
    if (Color > 0) then
    begin
      SMART_Canvas.canvas.Pen.Color := color;
    end else
    begin
      colour := i div 5 + i mod 5;
      case colour of
        0 : SMART_Canvas.canvas.Pen.Color := clWhite;
        1 : SMART_Canvas.canvas.Pen.Color := clYellow;
        2 : SMART_Canvas.canvas.Pen.Color := clBlue;
        3 : SMART_Canvas.canvas.Pen.Color := clLime;
        4 : SMART_Canvas.canvas.Pen.Color := clGreen;
      end;
    end;

    SMART_Canvas.canvas.moveto(TBA[i].x1,TBA[i].y1);
    SMART_Canvas.canvas.LineTo(TBA[i].x2,TBA[i].y1);
    SMART_Canvas.canvas.LineTo(TBA[i].x2,TBA[i].y2);
    SMART_Canvas.canvas.LineTo(TBA[i].x1,TBA[i].y2);
    SMART_Canvas.canvas.LineTo(TBA[i].x1,TBA[i].y1);
  end;

{$ELSE}
begin
{$ENDIF}
end;

procedure SMART_DrawBoxEx(Clear: boolean; Box: TBox; color: TColor);
begin
  SMART_DrawBoxes(Clear, [Box], color);
end;

procedure SMART_DrawBox(Box: TBox);
begin
  SMART_DrawBoxEx(True, Box, clRed);
end;

procedure SMART_DrawBoxMS(Clear: Boolean; Box: TBox; Color: TColor);
begin
  if (Box.X1 < MSX1) then Box.X1 := MSX1;
  if (Box.Y1 < MSY1) then Box.Y1 := MSY1;
  if (Box.X2 > MSX2) then Box.X2 := MSX2;
  if (Box.Y2 > MSY2) then Box.Y2 := MSY2;
  SMART_DrawBoxEx(Clear, Box, Color);
end;

procedure SMART_DrawLine(Clear: Boolean; TP1, TP2: TPoint; Color: TColor);
begin
{$IFDEF SMART}
  if (not SMART_DebugSetup) then
    SMART_SetupDebug();

  SMART_Canvas.canvas.Pen.Color := Color;

  if (Clear) then
    SMART_ClearCanvas;

  SMART_Canvas.canvas.moveto(TP1.x,TP1.y);
  SMART_Canvas.canvas.LineTo(TP2.x,TP2.y);
{$ENDIF}
end;

procedure SMART_DrawCircle(Clear: Boolean; Center: TPoint; Radius: Integer; Fill: Boolean; Color: TColor);
{$IFDEF SMART}
var
  TPA: TPointArray;
begin
  TPA := TPAFromBox(IntToBox(Center.X - Radius, Center.Y - Radius, Center.X + Radius, Center.Y + Radius));
  FilterPointsPie(TPA, 0, 360, -1, Radius, Center.X, Center.Y);

  if (not Fill) then
    FilterPointsDist(TPA, Radius-1, Radius, Center.X, Center.Y);

  if (Length(TPA) >= 1) then
    SMART_DrawDotsEx(Clear, TPA, Color);
{$ELSE}
begin
{$ENDIF}
end;

procedure SMART_DrawDot(Clear: Boolean; Point: TPoint; Color: TColor);
begin
  SMART_DrawCircle(Clear, Point, 1, true, Color);
end;

procedure SMART_DrawPolygons(Clear: Boolean; Polygons: T2DPointArray; color: TColor);
{$IFDEF SMART}
var
  i, h, Hi: Integer;
begin
  if (Clear) then
    SMART_ClearCanvas;

  if (Length(Polygons) < 1) then
    Exit;

  for h := 0 to High(Polygons) do
  begin
    Hi := High(Polygons[h]);
    if (Hi < 2) then Exit;

    for i := 0 to Hi - 1 do
      SMART_DrawLine(False, Polygons[h][i], Polygons[h][i+1], color);

    SMART_DrawLine(False, Polygons[h][Hi], Polygons[h][0], color);
  end;
{$ELSE}
begin
{$ENDIF}
end;

(*
SMART_DrawTextMulti
~~~~~~~~~~~~~~~~~~~

.. code-block:: pascal

  procedure SMART_DrawTextMulti(Clear, Shadow: Boolean; TP: TStringArray; Placement: TPoint; Font: string; Colour: TColor);

Draws text on the SMART canvas.  Used mainly for progress reports.  Parameters
are as follows:
    * Clear: Clear the SMART canvas before drawing
    * Shadow: if set to true, will add a shadow to the text
    * TP: the string array of what to be printed; each element is a different line
    * Placement: the point to start the text drawing
    * Font: the font to use (see Simba/Fonts/)
    * Colour: the color of the font

.. note::

    Author: Flight & Coh3n
    Last Modified: January 10th, 2012 by Coh3n

Example:

.. code-block:: pascal

    SMART_DrawTextMulti(['Time Run: '+TimeRunning', 'Logs Chopped: 10'], Point(10, 10), LoginChars, clRed, true);
*)
procedure SMART_DrawTextMulti(Clear, Shadow: Boolean; TP: TStringArray; Placement: TPoint; Font: string; Colour: TColor);
var
  i, b, h, TPH, Numb: Integer;
  TTP: TPointArray;
begin
  if (not SMART_DebugSetup) then
    SMART_SetupDebug();

  if (Clear) then
    SMART_ClearCanvas();

  TPH := High(TP);

  for i := 0 to TPH do
  begin
    TTP := LoadTextTPA(TP[i], Font, h);

    for b := 0 to High(TTP) do
    begin
      Numb := ((i + 1) * H);

      SMART_DrawDot(false, Point(TTP[b].x + Placement.x, TTP[b].y + Placement.y + Numb), Colour);
      if (Shadow) then
        SMART_DrawDot(false, Point(TTP[b].x + Placement.x + 1, TTP[b].y + + Placement.y + Numb + 1), 131072);
    end;
  end;
end;

procedure SMART_DrawTextEx(Clear: Boolean; x, y: Integer; font, Text: string; Color: TColor);
begin
  SMART_DrawTextMulti(Clear, true, [Text], Point(x, y), font, Color);
end;

procedure SMART_DrawText(x, y: Integer; font, Text: string; Color: TColor);
begin
  SMART_DrawTextEx(False, x, y, font, Text, Color);
end;

(*
SMART_DrawBitmap
~~~~~~~~~~~~~~~~

.. code-block:: pascal

  procedure SMART_DrawBitmap(Clear: Boolean; Bitmap: Integer; Placement: TPoint);

Draws a bitmap (Bitmap) on the SMART canvas at given coordinates (Placement).
Will clear the canvas beforehand if specified to do so (Clear).

.. note::

    Author: Coh3n
    Last Modified: January 10th, 2012 by Coh3n

Example:

.. code-block:: pascal

    SMART_DrawBitmap(true, bmp, point(5, 5));
*)
procedure SMART_DrawBitmap(Clear: Boolean; Bitmap: Integer; Placement: TPoint);
begin
  if (not SMART_DebugSetup) then
    SMART_SetupDebug();

  if (Clear) then
    SMART_ClearCanvas();

  DrawBitmap(Bitmap, SMART_Canvas.Canvas, Placement.X, Placement.Y);
end;

procedure SMART_FreeDebug();
begin
  try
    if (SMART_DebugSetup) then
      SMART_Canvas.Free;
  except
    Writeln('Failed to free SMART_Canvas bitmap: '+ExceptionToString(ExceptionType, ExceptionParam));
  end;
end;
