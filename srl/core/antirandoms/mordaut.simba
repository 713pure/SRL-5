(*
Mordaut
=======

Stores all the routines to solve the Mordaut random.  None of these routines
should be used throughout scripts.  They only need to be called in SRL's random
detection methods.

*)

//{$DEFINE SRL_RANDOMS_TEST}

{$IFDEF SRL_RANDOMS_TEST}
  {$i srl/srl.simba}
  {$i srl/srl/misc/debug.simba} // to make sure returnTPAExceptColors is working properly
  {$i common.simba}
{$ENDIF}

type
  TMDBigPuzzle = record
    name: string;
    idText: TStringArray;
    objs: TRotateObjectArray;
  end;
  TMDBigPuzzleArray = array of TMDBigPuzzle;

  TMDSmallPuzzle = record
    name: string;
    topObjs: TRotateObjectArray; // should ALWAYS be length 3
    btmObj: TRotateObject;
  end;
  TMDSmallPuzzleArray = array of TMDSmallPuzzle;

const
  MD_NPC_MORDAUT = 'D!!Do!g5qt';

  // new data for MD_GetObject will need to be gathered if these are to change
  MD_ACCURACY    = 50; // gets the average of MD_ACCURACY times to ID objects
  MD_OBJ_SIZE    = 25; // split TPA into this size of box

const
  MD_OBJ_SCIMITAR  = 0;
  MD_OBJ_LONGSWORD = 1;
  MD_OBJ_BATTLEAXE = 2;
  MD_OBJ_MACE      = 3;
  MD_OBJ_TEA       = 4;
  MD_OBJ_BEER      = 5;
  MD_OBJ_MARTINI   = 6;
  MD_OBJ_PICKAXE   = 7;
  MD_OBJ_ORE       = 8;
  MD_OBJ_HAMMER    = 9;
  MD_OBJ_BAR       = 10;
  MD_OBJ_SHORTBOW  = 11;
  MD_OBJ_ARROWS    = 12;
  MD_OBJ_CROSSBOW  = 13;
  MD_OBJ_LONGBOW   = 14;
  MD_OBJ_FROG      = 15;
  MD_OBJ_THIEF     = 16;
  MD_OBJ_MIME      = 17;
  MD_OBJ_NECKLACE  = 18;
  MD_OBJ_TIARA     = 19;
  MD_OBJ_SYMBOL    = 20;
  MD_OBJ_RING      = 21;

const
  MD_PUZZLE_BIG_COUNT = 10;
    MD_PUZZLE_BIG_DRINK    = 0;
    MD_PUZZLE_BIG_PIRATE   = 1;
    MD_PUZZLE_BIG_JEWEL    = 2;
    MD_PUZZLE_BIG_RANGE    = 3;
    MD_PUZZLE_BIG_FIRE     = 4;
    MD_PUZZLE_BIG_MELEE    = 5;
    MD_PUZZLE_BIG_MAGIC    = 6;
    MD_PUZZLE_BIG_DISGUISE = 7;
    MD_PUZZLE_BIG_HAT      = 8;
    MD_PUZZLE_BIG_FISH     = 9;

  MD_PUZZLE_SMALL_COUNT = 4;
    MD_PUZZLE_SMALL_WEAPONS = 0;
    MD_PUZZLE_SMALL_SMITH   = 1;
    MD_PUZZLE_SMALL_RANGE   = 2;
    MD_PUZZLE_SMALL_JEWEL   = 3;

var
  // stores the background colors and tolerances of the small and big puzzles
  MD_ExColSmall, MD_ExColBig, MD_ExTolSmall, MD_ExTolBig: TIntegerArray;

(**
 * Author: Coh3n
 * Description: Declares global variables.  Used so it can be easily updated.
 *)
procedure MD_DeclareGlobals();
begin
  // background colors of the small puzzle
  MD_ExColSmall := [4674119, 5265999];
  MD_ExTolSmall := [15, 15];

  // background colors of the big puzzle
  MD_ExColBig := [13423575, 12897741];
  MD_ExTolBig := [25, 25];
end;

(**
 * Author: DemiseScythe & Coh3n
 * Description: Returns true if player is in the random.
 *)
function MD_Detect(): boolean;
begin
  result := (getNPCChatName() = MD_NPC_MORDAUT) and (not tabExists(TAB_MAGIC));
end;

(**
 * Author: Coh3n
 * Description: Stores all the Mordaut object properties.  Data gathered using
 * MD_DebugSmall/BigPuzzle.
 *)
function MD_GetObject(obj: integer): TRotateObject;
begin
  case obj of
    MD_OBJ_SCIMITAR:
      with result do
      begin
        name := 'Scimitar';
        use := 'Weapon';
        count := 280;
        width := 41;
        height := 25;
        totalCount := 951;
        coverPercent := 29.0;
      end;

    MD_OBJ_LONGSWORD:
      with result do
      begin
        name := 'Longsword';
        use := 'Weapon';
        count := 107;
        width := 34;
        height := 23;
        totalCount := 670;
        coverPercent := 16.0;
      end;

    MD_OBJ_BATTLEAXE:
      with result do
      begin
        name := 'Battleaxe';
        use := 'Weapon';
        count := 218;
        width := 31;
        height := 19;
        totalCount := 591;
        coverPercent := 37.0;
      end;

    MD_OBJ_MACE:
      with result do
      begin
        name := 'Mace';
        use := 'Weapon';
        count := 250;
        width := 31;
        height := 22;
        totalCount := 681;
        coverPercent := 37.0;
      end;

    MD_OBJ_TEA:
      with result do
      begin
        name := 'Tea';
        use := 'Drink';
        count := 885;
        width := 33;
        height := 33;
        totalCount := 1134;
        coverPercent := 75.0;
      end;

    MD_OBJ_BEER:
      with result do
      begin
        name := 'Beer';
        use := 'Drink';
        count := 588;
        width := 26;
        height := 28;
        totalCount := 751;
        coverPercent := 75.0;
      end;

    MD_OBJ_MARTINI:
      with result do
      begin
        name := 'Martini';
        use := 'Drink';
        count := 426;
        width := 20;
        height := 33;
        totalCount := 671;
        coverPercent := 65.0;
      end;

    MD_OBJ_PICKAXE:
      with result do
      begin
        name := 'Pickaxe';
        use := 'Smithing';
        count := 304;
        width := 45;
        height := 30;
        totalCount := 1403;
        coverPercent := 22.0;
      end;

    MD_OBJ_ORE:
      with result do
      begin
        name := 'Ore';
        use := 'Smithing';
        count := 591;
        width := 38;
        height := 26;
        totalCount := 1053;
        coverPercent := 56.0;
      end;

    MD_OBJ_HAMMER:
      with result do
      begin
        name := 'Hammer';
        use := 'Smithing';
        count := 269;
        width := 30;
        height := 21;
        totalCount := 600;
        coverPercent := 44.0;
      end;

    MD_OBJ_BAR:
      with result do
      begin
        name := 'Bar';
        use := 'Smithing';
        count := 627;
        width := 33;
        height := 25;
        totalCount := 867;
        coverPercent := 72.0;
      end;

    MD_OBJ_SHORTBOW:
      with result do
      begin
        name := 'Shortbow';
        use := 'Range';
        count := 288;
        width := 40;
        height := 25;
        totalCount := 870;
        coverPercent := 33.0;
      end;

    MD_OBJ_ARROWS:
      with result do
      begin
        name := 'Arrows';
        use := 'Range';
        count := 232;
        width := 42;
        height := 27;
        totalCount := 975;
        coverPercent := 24.0;
      end;

    MD_OBJ_CROSSBOW:
      with result do
      begin
        name := 'Crossbow';
        use := 'Range';
        count := 247;
        width := 34;
        height := 24;
        totalCount := 847;
        coverPercent := 29.0;
      end;

    MD_OBJ_LONGBOW:
      with result do
      begin
        name := 'Longbow';
        use := 'Range';
        count := 161;
        width := 34;
        height := 21;
        totalCount := 664;
        coverPercent := 24.0;
      end;

    MD_OBJ_FROG:
      with result do
      begin
        name := 'Frog Mask';
        use := 'Disguise';
        count := 850;
        width := 34;
        height := 30;
        totalCount := 1055;
        coverPercent := 81.0;
      end;

    MD_OBJ_THIEF:
      with result do
      begin
        name := 'Thief Mask';
        use := 'Disguise';
        count := 560;
        width := 34;
        height := 28;
        totalCount := 944;
        coverPercent := 59.0;
      end;

    MD_OBJ_MIME:
      with result do
      begin
        name := 'Mime Mask';
        use := 'Disguise';
        count := 728;
        width := 33;
        height := 27;
        totalCount := 919;
        coverPercent := 79.0;
      end;

    MD_OBJ_NECKLACE:
      with result do
      begin
        name := 'Necklace';
        use := 'Jewelery';
        count := 190;
        width := 29;
        height := 19;
        totalCount := 532;
        coverPercent := 36.0;
      end;

    MD_OBJ_TIARA:
      with result do
      begin
        name := 'Tiara';
        use := 'Jewelery';
        count := 125;
        width := 32;
        height := 23;
        totalCount := 730;
        coverPercent := 17.0;
      end;

    MD_OBJ_SYMBOL:
      with result do
      begin
        name := 'Holy Symbol';
        use := 'Jewelery';
        count := 306;
        width := 40;
        height := 25;
        totalCount := 970;
        coverPercent := 32.0;
      end;

    MD_OBJ_RING:
      with result do
      begin
        name := 'Ring';
        use := 'Jewelery';
        count := 254;
        width := 24;
        height := 18;
        totalCount := 452;
        coverPercent := 56.0;
      end;

    else
      addToSRLLog('MD_GetObject: Invalid object '+toStr(obj));
  end;
end;

(**
 * Author: Coh3n
 * Description: results the DTMs to detect which "big" puzzle to solve.
 *)
function MD_GetBigPuzzles(): TMDBigPuzzleArray;
begin
  setLength(result, MD_PUZZLE_BIG_COUNT);

  with result[MD_PUZZLE_BIG_DRINK] do
  begin
    name := 'Big Puzzle: Drinks';
    idText := ['thir', 'drate', 'uench'];
    objs := [MD_GetObject(MD_OBJ_TEA), MD_GetObject(MD_OBJ_BEER),
             MD_GetObject(MD_OBJ_MARTINI)];
  end;

  with result[MD_PUZZLE_BIG_DISGUISE] do
  begin
    name := 'Big Puzzle: Disguise';
    idText := ['face', 'mask', 'disg'];
    objs := [MD_GetObject(MD_OBJ_FROG), MD_GetObject(MD_OBJ_THIEF),
             MD_GetObject(MD_OBJ_MIME)];
  end;
end;

(**
 * Author: Coh3n, DTMs by DemiseScythe
 * Description: results the DTMs for the possible "small" puzzles to solve.
 *)
function MD_GetSmallPuzzles(): TMDSmallPuzzleArray;
begin
  setLength(result, MD_PUZZLE_SMALL_COUNT);

  with result[MD_PUZZLE_SMALL_WEAPONS] do
  begin
    name := 'Small Puzzle: Weapons';
    btmObj := MD_GetObject(MD_OBJ_MACE);
    topObjs := [MD_GetObject(MD_OBJ_SCIMITAR), MD_GetObject(MD_OBJ_LONGSWORD),
                MD_GetObject(MD_OBJ_BATTLEAXE)];
  end;

  with result[MD_PUZZLE_SMALL_SMITH] do
  begin
    name := 'Small Puzzle: Smithing';
    btmObj := MD_GetObject(MD_OBJ_BAR);
    topObjs := [MD_GetObject(MD_OBJ_PICKAXE), MD_GetObject(MD_OBJ_ORE),
                MD_GetObject(MD_OBJ_HAMMER)];
  end;

  with result[MD_PUZZLE_SMALL_RANGE] do
  begin
    name := 'Small Puzzle: Range';
    btmObj := MD_GetObject(MD_OBJ_LONGBOW);
    topObjs := [MD_GetObject(MD_OBJ_SHORTBOW), MD_GetObject(MD_OBJ_ARROWS),
                MD_GetObject(MD_OBJ_CROSSBOW)];
  end;

  with result[MD_PUZZLE_SMALL_JEWEL] do
  begin
    name := 'Small Puzzle: Jewel';
    btmObj := MD_GetObject(MD_OBJ_RING);
    topObjs := [MD_GetObject(MD_OBJ_NECKLACE), MD_GetObject(MD_OBJ_TIARA),
                MD_GetObject(MD_OBJ_SYMBOL)];
  end;
end;

(**
 * Author: Coh3n
 * Description: Returns true if 'obj1' and 'obj2' are the same object.
 *)
function MD_ObjIsObj(obj1, obj2: TRotateObject): boolean;
var
  score: integer;
begin
  if (inRange(obj1.count, obj2.count - 10, obj2.count + 10)) then
    score := score + 3;

  if (inRange(obj1.width, obj2.width - 2, obj2.width + 2)) then
    score := score + 6;

  if (inRange(obj1.height, obj2.height - 2, obj2.height + 2)) then
    score := score + 6;

  if (inRange(obj1.totalCount, obj2.totalCount - 75, obj2.totalCount + 75)) then
    score := score + 3;

  if ((obj1.coverPercent > obj2.coverPercent - 3) and (obj1.coverPercent < obj2.coverPercent + 3)) then
    score := score + 8;

  //addToSRLLog('MD_ObjIsObj: Final score - '+toStr(score));
  result := (score >= 18); // best score is 26, result if score 18/26 or better
end;

(**
 * Author: Coh3n
 * Description: Returns a TBox of the big puzzle item slot 'Slot'. Top left
 * is slot 1, botton right is slot 15.
 *)
function MD_BigBox(slot: integer): TBox;
begin
  result := gridBox(slot, 5, 3, 60, 80, 67, 91, point(71, 73));
end;

(**
 * Author: Coh3n
 * Description: Returns a TBox of the small puzzle item slot 'Slot'. Top left
 * is slot 1, botton right is slot 8.
 *)
function MD_SmallBox(slot: integer): TBox;
begin
  result := gridBox(slot, 4, 2, 95, 80, 95, 150, point(110, 100));
end;

(**
 * Author: Nava2
 * Description: Returns true if the big puzzle screen is open.
 *)
function MD_BigScreen(): boolean;
var
  dtmThumb, x, y: integer;
begin
  dtmThumb := DTMFromString('78DA63E4646060E063400187BBD3184480342310FF0702466E208309558D083333030B540D08300A619A83A146002488AA86879911550D1B901025A006E4161E5435E2DC2C286A00ACBB06F0');
  result := findDTM(dtmThumb, x, y, MSX1, MSY1, MSX2, MSY2);
  freeDTM(dtmThumb);
end;

(**
 * Author: Nava2
 * Description: Returns true if the small puzzle screen is open.
 *)
function MD_SmallScreen(): boolean;
begin
  // counts black pixels of the text shadow in the middle of the MS
  result := (countColor(clBlack, 165, 142, 357, 183) = 322);
end;

(**
 * Author: Coh3n
 * Description: Returns the object scanned in 'slot' for the big puzzle.
 *)
function MD_ScanBigObject(slot: integer): TRotateObject;
begin
  result := scanRotateObject(
    MD_ExColBig, MD_ExTolBig, MD_BigBox(slot), MD_OBJ_SIZE, MD_ACCURACY);
end;

(**
 * Author: Coh3n
 * Description: Returns the object scanned in 'slot' for the small puzzle.
 *)
function MD_ScanSmallObject(slot: integer): TRotateObject;
begin
  result := scanRotateObject(
    MD_ExColSmall, MD_ExTolSmall, MD_SmallBox(slot), MD_OBJ_SIZE, MD_ACCURACY);
end;

(**
 * Author: Coh3n & DemiseScythe
 * Description: Returns which small puzzle we have to solve.
 *)
function MD_IDSmallPuzzle(puzzles: TMDSmallPuzzleArray): integer;
var
  i, j, k, c: integer;
  scanObjs, finalObjs: TRotateObjectArray;
begin
  if (not loggedIn()) or (not MD_SmallScreen()) then
    exit;

  addToSRLLog('MD_IDSmallPuzzle: Identifying puzzle');
  result := -1;

  addToSRLLog('MD_IDSmallPuzzle: Scanning objects...');

  // get the top three objects (takes a few seconds)
  setLength(scanObjs, 3);
  for i := 0 to high(scanObjs) do // first 3 item slots
    scanObjs[i] := MD_ScanSmallObject(i + 1);

  addToSRLLog('MD_IDSmallPuzzle: Objects scanned');

  setLength(finalObjs, 3);

  // loop through the puzzles and their objects and compare to the scanned objects
  for i := 0 to high(puzzles) do
  begin
    c := 0; // needs to reset for each puzzle

    for j := 0 to high(puzzles[i].topObjs) do
      for k := 0 to high(scanObjs) do
        if (MD_ObjIsObj(puzzles[i].topObjs[j], scanObjs[k])) then
        begin
          addToSRLLog('MD_IDSmallPuzzle: Found '+puzzles[i].topObjs[j].name+' in slot '+toStr(k + 1));
          finalObjs[j] := puzzles[i].topObjs[j];
          inc(c);
          break;
        end;

    // if 2 or more of the right objects are found, we've ID'd the puzzle
    if (c >= 2) then
    begin
      result := i;
      break;
    end;
  end;

  if (result <> -1) then
    addToSRLLog('MD_IDSmallPuzzle: Found '+puzzles[result].name+' ('+toStr(c)+'/3 objects'+')')
  else
    addToSRLLog('MD_IDSmallPuzzle: Didn''t ID puzzle');
end;

(**
 * Author: Coh3n & DemiseScythe
 * Description: Solves the small puzzle (calls MD_GetSmallPuzzle).
 *)
function MD_SolveSmallPuzzle(puzzle: TMDSmallPuzzle): boolean;
var
  i: integer;
  tmpObj: TRotateObject;
begin
  if (not loggedIn()) then
    exit;

  addToSRLLog('MD_SolveSmallPuzzle: Solving...');

  for i := 5 to 8 do // object slots 5-8 (bottom half)
  begin
    tmpObj := MD_ScanSmallObject(i);

    if (MD_ObjIsObj(tmpObj, puzzle.btmObj)) then
    begin
      addToSRLLog('MD_SolveSmallPuzzle: Found '+puzzle.btmObj.name+' in slot '+toStr(i));

      // needs specific coords because you can't click anywhere on the item
      mouse(108 + (100 * (i - 5)), 235, 3, 3, mouse_Move);
      wait(1500 + random(500));
      result := true;
      break;
    end;
  end;

  if (result) then
    addToSRLLog('MD_SolveSmallPuzzle: Solved '+puzzle.name)
  else
    addToSRLLog('MD_SolveSmallPuzzle: Didn''t solve');
end;

(**
 * Author: Coh3n
 * Description: Identifies which of the big puzzles we have to solve.
 *)
function MD_IDBigPuzzle(puzzles: TMDBigPuzzleArray): integer;
var
  i, j: integer;
begin
  if (not loggedIn()) then
    exit;

  result := -1;

  // loops through the possible texts in each puzzle in the 'puzzles' array
  for i := 0 to high(puzzles) do
    for j := 0 to high(puzzles[i].idText) do
      // the text on the right size of the puzzle
      if (findTextTPA(13290961, 25, 373, 60, 473, 160, puzzles[i].idText[j], smallCharsNS, nothing)) then
      begin
        addToSRLLog('MD_GetBigPuzzle: Found '+puzzles[i].name);
        result := i;
        exit;
      end;

  addToSRLLog('MD_GetBigPuzzle: Failed to identify big puzzle');
end;

(**
 * Author: Coh3n & DemiseScythe
 * Description: Solves the big 'puzzle'. Constants at the top of the file.  Will
 * randomly choose slots to scan, then remove that slot from an array. Will
 * check every slot before starting over. Starts over a set number of tries.
 *)
function MD_SolveBigPuzzle(puzzle: TMDBigPuzzle): boolean;
var
  i, clicks, slotsLen, time, index, t: integer;
  objFound: TBooleanArray;
  slots: TIntegerArray;
  tmpObj: TRotateObject;
  p: TPoint;
begin
  markTime(time);

  if ((not loggedIn()) or (not MD_BigScreen())) then
    exit;

  addToSRLLog('MD_SolveBigPuzzle: Solving...');
  setLength(objFound, length(puzzle.objs));

  // scan the entire puzzle a maximum of 5 times
  for t := 1 to 5 do
  begin
    slots := [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15];
    slotsLen := length(slots);

    addToSRLLog('MD_SolveBigPuzzle: Scanning for objects (try '+toStr(t)+')...');

    // randomly chooses a slot to look for the objects
    repeat
      index := random(length(slots));
      p := middleBox(MD_BigBox(slots[index]));

      tmpObj := MD_ScanBigObject(slots[index]);
      for i := 0 to high(puzzle.objs) do
      begin
        if (objFound[i]) then // don't want to look for the same object twice
          continue;

        if (MD_ObjIsObj(tmpObj, puzzle.objs[i])) then
        begin
          addToSRLLog('MD_SolveBigPuzzle: Found '+puzzle.objs[i].name+' in slot '+toStr(slots[index]));
          mouse(p.x, p.y, 20, 30, mouse_Left);
          objFound[i] := true;
          inc(clicks);
          break;
        end;
      end;

      // remove the index so we don't search the same box twice
      deleteValueInIntArray(slots, index);

      result := (clicks >= 3); // only need to click 3 times

    until((length(slots) <= 0) or result);

    if (result) then
      break;
  end;

  if (result) then
  begin
    addToSRLLog('MD_SolveBigPuzzle: Solved in '+toStr(timeFromMark(time))+'ms');
    wait(500 + random(500));
    mouse(429, 270, 7, 7, mouse_Move); // click the thumb
  end else
    addToSRLLog('MD_SolveBigPuzzle: Didn''t solve '+puzzle.name);
end;

// debugs each rotating item in the Mordaut small puzzle
procedure MD_DebugPuzzle(slots: TIntegerArray; big: boolean);
var
  i: integer;
begin
  MD_DeclareGlobals();

  for i := 0 to high(slots) do
    if (big) then
      debugRotateObject(MD_ScanBigObject(slots[i]))
    else
      debugRotateObject(MD_ScanSmallObject(slots[i]));
end;

(**
 * Author: Coh3n
 * Description: Solves the random.
 *)
const
  _MD_MAX = 6; // maximum puzzle tries

function MD_Solve(): boolean;
var
  t, puz, tries: integer;
  bigPuzzles: TMDBigPuzzleArray;
  smallPuzzles: TMDSmallPuzzleArray;
begin
  if (not loggedIn()) then
    exit;

  t := (getSystemTime + (10 * 60000));
  doConversation('', false);

  MD_DeclareGlobals();
  bigPuzzles := MD_GetBigPuzzles();
  smallPuzzles := MD_GetSmallPuzzles();

  repeat
    // solve the big puzzle
    if (MD_BigScreen()) then
    begin
      inc(tries);
      puz := MD_IDBigPuzzle(bigPuzzles);

      if (puz <> -1) then
        if (MD_SolveBigPuzzle(bigPuzzles[puz])) then
          waitNPCTalking(MD_NPC_MORDAUT, 3000);
    end;

    // solve the small puzzle
    if (MD_SmallScreen()) then
    begin
      inc(tries);
      puz := MD_IDSmallPuzzle(smallPuzzles);

      if (puz <> -1) then
        if (MD_SolveSmallPuzzle(smallPuzzles[puz])) then
          waitNPCTalking(MD_NPC_MORDAUT, 3000);
    end;

    doConversation('', false); // to bring up the next puzzle

  until(result or (getSystemTime > t));

  if (not result) then
    addToSRLLog('MD_Solve: Mordaut solver timed out');
end;

{$IFDEF SRL_RANDOMS_TEST}
begin
  clearDebug();
  activateClient();
  setupSRL();
  SRL_DisableLogging := true;

  MD_Solve();
  //MD_DeclareGlobals();
  //MD_DebugPuzzle([7], false);
end.
{$ENDIF}
