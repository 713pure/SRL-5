(*
Minimap
=======

The Minimap include contains all igeneral Minimap related functions

.. contents::

*)

(*
rs_GetCompassAngleRadians
~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: pascal

    function rs_GetCompassAngleRadians: Extended;

Returns the compass angle in radians.

.. note::

    by ReadySteadyGo

Example:

.. code-block:: pascal

*)
function rs_GetCompassAngleRadians: Extended;
var
  tpa: TPointArray;
  atpa: T2DPointArray;
  i, h, l, cts: Integer;
  VectorArray: Array of TVector;
  RefPoint: TPoint;
  angles: TExtendedArray;
begin
  cts := GetColorToleranceSpeed;
  ColorToleranceSpeed(1);
  { Colour of 3 E/S/W dots }
  FindColorsTolerance(tpa, 2370604, 529, 9, 558, 39, 5);
  ColorToleranceSpeed(cts);

  atpa := SplitTPA(tpa, 1);

  h := High(atpa);
  setLength(tpa, h+1);
  l := 0;
  for i := 0 to h do
    { Gets rid of dots under length of 3 and get the MiddleTPA }
    if high(atpa[i]) > 4 then
    begin
      tpa[l] := MiddleTPA(atpa[i]);
      inc(l);
    end;

  if l < 3 then
    Exit;

  setLength(tpa, l);

  FilterPointsDist(tpa, 9, 20, 543, 24);

  SetLength(VectorArray, 3);

  for i := 0 to 2 do
    VectorArray[i] := CreateVector(Point(543, 24), tpa[i], True);

  angles := [AngleBetween(VectorArray[0], VectorArray[1]),
         AngleBetween(VectorArray[1], VectorArray[2]),
         AngleBetween(VectorArray[2], VectorArray[0])];

  for i := 0 to 2 do
  begin
    if angles[i] > MATH_PI then
      angles[i] := MATH_2PI - angles[i];
    { compare angle between, > 100 then it's the south dot }
    if angles[i] > radians(100) then
    begin
      case i of
        0: RefPoint := tpa[2];
        1: RefPoint := tpa[0];
        2: RefPoint := tpa[1];
      end;
      { break the loop, we have reference pt. }
      break;
    end;
  end;


  { Using the south dot to measure compass angle.. }
  Result := ArcTan2(-(RefPoint.Y - 24), RefPoint.X - 543) - Radians(80);
  Result := fixRad(Result - MATH_PI - 0.05*MATH_PI);
end;

(*
rs_GetCompassAngleDegrees
~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: pascal

    function rs_GetCompassAngleDegrees: Extended;

Returns the compass angle in degrees.

.. note::

    by Wizzup?

Example:

.. code-block:: pascal

*)
function rs_GetCompassAngleDegrees: Extended;
begin
  Result := Degrees(rs_GetCompassAngleRadians());
end;


(*
rs_OnMinimap
~~~~~~~~~~~~

.. code-block:: pascal

    function rs_OnMinimap(x, y: Integer): Boolean;

Checks wether the specified point is on the minimap.

.. note::

    by Raymond

Example:

.. code-block:: pascal

*)
function rs_OnMinimap(x, y: Integer): Boolean;
begin
  Result := InCircle(x, y, MMCX, MMCY, 73);
end;

(*
FindFlag
~~~~~~~~

.. code-block:: pascal

    function FindFlag(var X, Y: Integer): Boolean;

Returns true if the flag is found on the minimap.

.. note::

    by weequ

Example:

.. code-block:: pascal

  if (FindFlag(x, y)) then
  begin
    writeln('Flag found');
    mouse(x, y, 3, 3, true);
  end;
*)
function FindFlag(var X, Y: Integer): Boolean;
var
  I: Integer;
  TPA: TPointArray;
begin
  Freeze;
  FindColors(TPA, 65536, MMX1, MMY1, MMX2, MMY2);
  if (Length(TPA) <= 0) then
  begin
    UnFreeze;
    Exit;
  end;
  for I := 0 to High(TPA) do
  begin
    if (GetColor(TPA[I].X-1, TPA[I].Y-1) - GetColor(TPA[I].X, TPA[I].Y-1) = 6381921) then
    begin
      UnFreeze;
      X := TPA[I].x;
      Y := TPA[I].y;
      Result := True;
      Exit;
    end;
  end;
  UnFreeze;
  Result := False;
end;

(*
FlagPresent
~~~~~~~~~~~

.. code-block:: pascal

    function FlagPresent: Boolean;

T/F depending on flag exist.


.. note::

    by weequ

Example:

.. code-block:: pascal


*)
function FlagPresent: Boolean;
var
  X, Y: Integer;
begin
  Result := FindFlag(X, Y);
end;

(*
FlagDistance
~~~~~~~~~~~~

.. code-block:: pascal

    function FlagDistance: Integer;

Returns distance in pixels your char dot is from flag on mini-map


.. note::

    by weequ

Example:

.. code-block:: pascal


*)
function FlagDistance: Integer;
var
  X, Y: Integer;
begin
  Result := -1;
  if (FindFlag(X, Y)) then
    Result := Distance(MMCX, MMCY, X, Y);
end;

(*
WalkingToFlag
~~~~~~~~~~~~~

.. code-block:: pascal

    function WalkingToFlag(WaitTime: Integer): Boolean;

Checks if your charachter is moving; stores current FlagDistance to a variable,
waits "WaitTime" ms and then checks the FlagDistance again.
If it differs from the Distance stored in the variable, function returns true.

.. note::

    by EvilChicken!

Example:

.. code-block:: pascal


*)
function WalkingToFlag(WaitTime: Integer): Boolean;
var
  FirstDistance: Integer;
begin
  Result := False;
  if (not FlagPresent) then exit;
  FirstDistance := FlagDistance;
  Wait(WaitTime);
  Result := (FirstDistance <> FlagDistance);
end;

function RoadColorChecker: Boolean; Forward;

(*
FlagEx
~~~~~~

.. code-block:: pascal

    function FlagEx(Dist: Integer; RoadColorCheck: Boolean): Boolean;

Waits until Flag is within "Distance" distance.

.. note::

    by Wizzup? / WT-Fakawi / ZephyrsFury / N1ke! / weequ

Example:

.. code-block:: pascal


*)
function FlagEx(Dist: Integer; RoadColorCheck: Boolean): Boolean;
var
  Tx, Ty, M, D1, D2: Integer;
begin
  Result := False;
  M := GetSystemTime;
  while (FindFlag(Tx, Ty)) do
  begin
    wait(50);
    D1 := Distance(Tx, Ty, MMCX, MMCY);
    if (D1 <= Dist) then
    begin
      Result := True;
      Exit;
    end;
    if (RoadColorCheck) then
      RoadColorChecker;
    Wait(100);
    if (GetColor(6, 6) <> clWhite) then
      if (GetSystemTime - M > 5000) then
      begin
        if (D1 = D2) then Exit;
        D2 := D1;
        M := GetSystemTime;
      end;
    if (Random(20) = 0) then IdleTime(500, 1000, 0.01);
    if SRL_Procs[SRL_AntiBan] <> nil then
      SRL_Procs[SRL_AntiBan]();
  end;
  Wait(RandomRange(200, 400));
end;

(*
MouseFlagEx
~~~~~~~~~~~

.. code-block:: pascal

    function MouseFlagEx(X, Y, rX, rY, Xmod, Ymod, FlagDist: Integer; CheckForFlag, CheckForRoadColor: Boolean): Boolean;

MouseFlag, MFF & MFNF combined into one procedure.
X, Y is the point you want to click, rX, rY are randomness modifiers.
Xmod and Ymod is the adjustment for each click without finding a flag.
FlagDist is how close you want to be (in pixels) to the flag before exiting.
CheckForFlag = True if you want to exit the function if a flag is present. (MFF)
CheckForRoadColor = True if you want to call RoadColorChecked while FlagPresent.

.. note::

    by EvilChicken!

Example:

.. code-block:: pascal


*)
function MouseFlagEx(X, Y, rX, rY, Xmod, Ymod, FlagDist: Integer;
  CheckForFlag, CheckForRoadColor: Boolean): Boolean;
var
  I: Integer;
  P: TPoint;
begin
  Result := False;
  if (FlagPresent) then
    if (CheckForFlag) or (FlagDistance <= FlagDist) then exit;

  P := Point(X - Xmod, Y - Ymod);
  Xmod := Max(Xmod, 3);
  Ymod := Max(Ymod, 3);

  for I := 0 to 4 do
  begin
    IncEx(P.X, Xmod + Random(rX));
    IncEx(P.Y, Ymod + Random(rY));
    if not rs_OnMiniMap(P.X, P.Y) then Continue;
    Mouse(P.X, P.Y, 0, 0, mouse_left);
    Result := WaitFunc(@FlagPresent, 50, 3000);
    if (Result) then break;
  end;
  if (FlagDist > -1) then
    FlagEx(FlagDist, CheckForRoadColor);
end;

(*
MFF
~~~

.. code-block:: pascal

    function MFF(X, Y, Xmod, Ymod: Integer): Boolean;


If the flag is not present it will click at (ax, ay) increasing by
(xmod, ymod) 5 times or until the flag appears.


.. note::

    by EvilChicken! from an original idea by WT-Fakawi

Example:

.. code-block:: pascal


*)
function MFF(X, Y, Xmod, Ymod: Integer): Boolean;
begin
  Result := MouseFlagEx(X, Y, 3, 3, Xmod, Ymod, -1, True, False);
end;

(*
MFNF
~~~~

.. code-block:: pascal

    Function MFNF(ax, ay, xmod, ymod: Integer):Boolean;

Like MFF except it will click even if the flag is present when the

.. note::

    by EvilChicken! from an original idea by WT-Fakawi

Example:

.. code-block:: pascal


*)
function MFNF(X, Y, Xmod, Ymod: Integer): Boolean;
begin
  Result := MouseFlagEx(X, Y, 3, 3, Xmod, Ymod, -1, False, False);
end;

(*
FFlag
~~~~~

.. code-block:: pascal

    function FFlag(Dist: Integer): Boolean;

Waits until Flag is within "Distance" distance.


.. note::

    by Wizzup? / WT-Fakawi / ZephyrsFury

Example:

.. code-block:: pascal


*)
function FFlag(Dist: Integer): Boolean;
begin
  Result := FlagEx(Dist, False);
end;

(*
Flag
~~~~

.. code-block:: pascal

    function Flag: Boolean;

Waits while flag exists.


.. note::

    by Nava2

Example:

.. code-block:: pascal


*)

function Flag: Boolean;
begin
  Result := FlagEx(0, False);
end;

(*
MouseFlag
~~~~~~~~~

.. code-block:: pascal

    procedure MouseFlag(X, Y, rX, rY, FlagDist: Integer);

Mouse and Flag combined into one easy procedure.


.. note::

    by EvilChicken!

Example:

.. code-block:: pascal


*)

function MouseFlag(X, Y, rX, rY, FlagDist: Integer): Boolean;
begin
  Result := MouseFlagEx(X, Y, rX, rY, 0, 0, FlagDist, False, False);
end;
